package services

import (
	"fmt"
	"github.com/neo4j-graphacademy/neoflix/pkg/ioutils"
	"github.com/neo4j-graphacademy/neoflix/pkg/services/jwtutils"
	"github.com/neo4j/neo4j-go-driver/v4/neo4j"
	"golang.org/x/crypto/bcrypt"
)

type User map[string]interface{}

type AuthService interface {
	Register(email, plainPassword, name string) (User, error)

	LogIn(email string, password string) (User, error)
}

type neo4jAuthService struct {
	driver    neo4j.Driver
	jwtSecret string
}

func NewNeo4jAuthService(driver neo4j.Driver, jwtSecret string) AuthService {
	return &neo4jAuthService{
		driver:    driver,
		jwtSecret: jwtSecret,
	}
}

// Register should create a new User node in the database with the email and name
// provided, along with an encrypted version of the password and a `userId` property
// generated by the server.
//
// The properties also be used to generate a JWT `token` which should be included
// with the returned user.
// tag::register[]
func (as *neo4jAuthService) Register(email, plainPassword, name string) (user User, err error) {
	encryptedPassword, err := encryptPassword(plainPassword)
	if err != nil {
		return nil, err
	}

	// Open a new Session
	// tag::catch[]
	session := as.driver.NewSession(neo4j.SessionConfig{})
	defer func() {
		err = ioutils.DeferredClose(session, err)
	}()

	// tag::create[]
	result, err := session.WriteTransaction(func(tx neo4j.Transaction) (interface{}, error) {
		result, err := tx.Run(`
			CREATE (u:User {
				  userId: randomUuid(),
				  email: $email,
				  password: $encrypted,
				  name: $name
			})
			RETURN u { .userId, .name, .email } as u`,
			map[string]interface{}{
				"email":     email,
				"encrypted": encryptedPassword,
				"name":      name,
			})
		// end::create[]
		if err != nil {
			return nil, err
		}
		// tag::extract[]
		// Extract safe properties from the user node (`u`) in the first row
		record, err := result.Single()
		if err != nil {
			return nil, err
		}
		user, _ := record.Get("u")
		return user, nil
		// end::extract[]
	})
	if err != nil {
		return nil, err
	}

	user = result.(map[string]interface{})
	subject := user["userId"].(string)
	token, err := jwtutils.Sign(subject, userToClaims(user), as.jwtSecret)
	if err != nil {
		return nil, err
	}
	// tag::return[]
	user = result.(map[string]interface{})
	return userWithToken(user, token), nil
	// end::return[]
	// end::catch[]
}

func (as *neo4jAuthService) LogIn(email string, password string) (user User, err error) {
	// Open a new Session
	// tag::catch[]
	session := as.driver.NewSession(neo4j.SessionConfig{})
	defer func() {
		err = ioutils.DeferredClose(session, err)
	}()

	// tag::query[]
	// Find the User node within a Read Transaction
	result, err := session.ReadTransaction(func(tx neo4j.Transaction) (interface{}, error) {
		result, err := tx.Run(`
			MATCH (u:User {email: $email}) RETURN u`,
			map[string]interface{}{
				"email": email,
			})
		if err != nil {
			return nil, err
		}
		record, err := result.Single()
		if err != nil {
			// do not expose whether an account matches or not
			return nil, fmt.Errorf("account not found or incorrect password")
		}
		user, _ := record.Get("u")
		return user, nil
	})
	// end::query[]

	if err != nil {
		return nil, err
	}

	// tag::password[]
	// Check password
	userNode := result.(neo4j.Node)
	user = userNode.Props
	if !verifyPassword(password, user["password"].(string)) {
		return nil, fmt.Errorf("account not found or incorrect password")
	}
	// end::password[]

	// tag::return[]
	subject := userNode.Props["userId"].(string)
	token, err := jwtutils.Sign(subject, userToClaims(user), as.jwtSecret)
	if err != nil {
		return nil, err
	}
	return userWithToken(user, token), nil
	// end::return[]
}

func encryptPassword(password string) (string, error) {
	hash, err := bcrypt.GenerateFromPassword([]byte(password), 12)
	if err != nil {
		return "", err
	}
	return string(hash), nil
}

func verifyPassword(password, hash string) bool {
	err := bcrypt.CompareHashAndPassword(
		[]byte(hash),
		[]byte(password),
	)
	return err == nil
}

func userToClaims(user User) map[string]interface{} {
	return map[string]interface{}{
		"sub":    user["userId"],
		"userId": user["userId"],
		"name":   user["name"],
	}
}

func userWithToken(user User, token string) User {
	return map[string]interface{}{
		"token":  token,
		"userId": user["userId"],
		"email":  user["email"],
		"name":   user["name"],
	}
}

// end::register[]
