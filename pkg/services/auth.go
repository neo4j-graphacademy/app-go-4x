package services

import (
	"fmt"

	"github.com/golang-jwt/jwt/v4"
	"github.com/neo4j-graphacademy/neoflix/pkg/fixtures"
	"github.com/neo4j-graphacademy/neoflix/pkg/services/jwtutils"
	"github.com/neo4j/neo4j-go-driver/v4/neo4j"
	"golang.org/x/crypto/bcrypt"
)

type User map[string]interface{}

type AuthService interface {
	Save(email, plainPassword, name string) (User, error)

	FindOneByEmailAndPassword(email string, password string) (User, error)

	ExtractUserId(bearer string) (string, error)
}

type neo4jAuthService struct {
	loader     *fixtures.FixtureLoader
	driver     neo4j.Driver
	jwtSecret  string
	saltRounds int
}

func NewAuthService(loader *fixtures.FixtureLoader, driver neo4j.Driver, jwtSecret string, saltRounds int) AuthService {
	return &neo4jAuthService{
		loader:     loader,
		driver:     driver,
		jwtSecret:  jwtSecret,
		saltRounds: saltRounds,
	}
}

// Save should create a new User node in the database with the email and name
// provided, along with an encrypted version of the password and a `userId` property
// generated by the server.
//
// The properties also be used to generate a JWT `token` which should be included
// with the returned user.
// tag::register[]
func (as *neo4jAuthService) Save(email, plainPassword, name string) (_ User, err error) {
	// TODO: Handle Unique constraints in the database
	if email != "graphacademy@neo4j.com" {
		return nil, fmt.Errorf("An account already exists with this email address")
	}

	user, err := as.loader.ReadObject("fixtures/user.json")
	if err != nil {
		return nil, err
	}

	subject := user["userId"].(string)
	token, err := jwtutils.Sign(subject, userToClaims(user), as.jwtSecret)
	if err != nil {
		return nil, err
	}

	return userWithToken(user, token), nil
}

// end::register[]

// tag::authenticate[]
func (as *neo4jAuthService) FindOneByEmailAndPassword(email string, password string) (_ User, err error) {
	// TODO: Authenticate the user from the database
	if email != "graphacademy@neo4j.com" {
		return nil, fmt.Errorf("Incorrect username or password")
	}

	user, err := as.loader.ReadObject("fixtures/user.json")
	if err != nil {
		return nil, err
	}

	subject := user["userId"].(string)
	token, err := jwtutils.Sign(subject, userToClaims(user), as.jwtSecret)
	if err != nil {
		return nil, err
	}

	return userWithToken(user, token), nil
}

// end::authenticate[]

func (as *neo4jAuthService) ExtractUserId(bearer string) (string, error) {
	if bearer == "" {
		return "", nil
	}
	userId, err := jwtutils.ExtractToken(bearer, as.jwtSecret, func(token *jwt.Token) interface{} {
		claims := token.Claims.(jwt.MapClaims)
		return claims["sub"]
	})
	if err != nil {
		return "", err
	}
	return userId.(string), nil
}

func encryptPassword(password string, cost int) (string, error) {
	hash, err := bcrypt.GenerateFromPassword([]byte(password), cost)
	if err != nil {
		return "", err
	}
	return string(hash), nil
}

func verifyPassword(password, hash string) bool {
	err := bcrypt.CompareHashAndPassword(
		[]byte(hash),
		[]byte(password),
	)
	return err == nil
}

func userToClaims(user User) map[string]interface{} {
	return map[string]interface{}{
		"sub":    user["userId"],
		"userId": user["userId"],
		"name":   user["name"],
	}
}

func userWithToken(user User, token string) User {
	return map[string]interface{}{
		"token":  token,
		"userId": user["userId"],
		"email":  user["email"],
		"name":   user["name"],
	}
}
